Pourquoi préférer un clavier par rapport à une souri ?
Lignes de commandes = texte donc on peut notamment stoker le texte quelque part (on garde les opérations réaliser, on peut ensuite les automatiser…)

--------------------------------------------------------------------------------------------------------------------------
2 grandes familles de langages :
-	Langages compilés (java…) : on écrit du teste, on le met dans des fichiers, on compile et on peut lancer notre programme
-	Langages interprétés () : on a un programme (un interpréteur) qui va au fur et à mesure, à chaque fois qu’on envoie une ligne elle est interprétée (environnement REPL Read Eval Print Loop)

En ligne de commande on est dans le deuxième cas

--------------------------------------------------------------------------------------------------------------------------
DSL domaine spécifique langage (utilisé seulement pour faire un sous ensemble de tâches et rien d’autre)

--------------------------------------------------------------------------------------------------------------------------
Bash : langage spécialement fait pour manipuler les objets (on peut appeler n’importe quel programme). C’est le Shell le plus répandu

Comment il sait où est le programme ?
Le chemin absolu à partir de la racine
Sur linux doit être modifiable de manière dynamique
On a donc une variable d’environnent  qui contient les noms des chemins : PATH
On utilise des majuscules pour les variables pour les faire ressortir 
$PATH pour appeler 
Par défaut exécute les fonctions, pour les afficher : echo
SHELL variable d’environnent qui nous permet de savoir quel shell on utilise

--------------------------------------------------------------------------------------------------------------------------
Commandes de bases :
ls : lister
cp : copier
cd : change le working directory
touch : créer un fichier vide
man : afficher la doc d’une commande
false : ne fait rien et retourne faux
cut : retire des parties des lignes d’un fichier
pwd : affiche le nom du directory actuellement utilisé (affiche où iront par défaut les fichiers créés)
uniq : filtre les doublons (mais uniquement s’ils sont consécutifs)
sort : trie des données
cat : 
wget :
curl :
tr : translate
head :
…

--------------------------------------------------------------------------------------------------------------------------
$HOME correspond à ~

--------------------------------------------------------------------------------------------------------------------------
Editeur de texte pour lire /etc/passwd : [nom éditeur de texte] [nom du fichier à éditer]
Utiliser vi ou vim comme éditeur de texte
Pour quitter :q
 
--------------------------------------------------------------------------------------------------------------------------
Sous Bash on a la complétion automatique : tab -> complète directement s’il y a qu’une seule solution ou la liste s’il y en a plusieurs

--------------------------------------------------------------------------------------------------------------------------
Obtenir la liste des shells (non triée et avec doublons):
cut  /etc/passwd –d « : » -f 7

notion de redirection : par défaut la sortie de texte s’affiche sur le termi,al mais on peut rediriger vers un fichier texte.
cut  /etc/passwd –d « : » -f 7 > [nom d’un fichier].txt

On veut maintenant une liste sans doublons qui affiche le nombre d’utilisation et trie du plus utilisé au moins utilisé. On fait ça progressivement. Avec sort on trie les données et avec uniq on se débarrasse des doublons :

cut  /etc/passwd –d « : » -f 7 > allShells.txt
sort allShells.txt > allShellsSorted.txt
uniq –c allShellsSorted.txt > allShellsSortedUniq.txt
sort –nr allShellsSortedUniq.txt

Pour tout faire en une fois :
cut  /etc/passwd –d « : » -f 7 | sort | uniq –c | sort –nr

--------------------------------------------------------------------------------------------------------------------------
tr –c [ :alpha :]  ‘\n’ < gutenberg.txt > gutenbergSorted.txt
(prend tous les mots du premier fichier pour les afficher sous forme de liste dans le deuxième fichier)
Tr « A-Z » « a-z » < gutenbergSorted.txt  > gutenbergSortedLowerCase.txt
(met tout en minuscule)

